#version 460

/*  required #defines:

    WORKGROUP_SIZE_X: the x dimension size of the work group
    WORKGROUP_SIZE_Y: the y dimension size of the work group
    BATCH_SIZE: batch size; the x dimension of the work group
    PERMUTATIONS: number of permutations; the y dimension of the work group
    STACK_SIZE: size of private stack; should not be smaller than expression tree
    MAX_TREE_SIZE: maximum tree size; used for stride petween permutation rows

    OPKINDs: uint literals
    - OPKIND_VARIABLE
    - OPKIND_CONSTANT
    - OPKIND_FUNCTION

    a definition of the `_eval` function is also required
*/

layout (std430, set = 0, binding = 0) readonly buffer Preimage {
    float preimage[];
};

layout (std430, set = 0, binding = 1) readonly buffer Image {
    float image[];
};

layout (std430, set = 1, binding = 0) readonly buffer ConstantPool {
    float constants[];
};

// a set of indices into the preimage; batch size == number of summands in MSD per permutation
layout (std430, set = 1, binding = 1) readonly buffer Batch {
// size == BATCH_SIZE
    uint batch[];
};

// prefactors to multiply a tree node by; one per node
layout (std430, set = 1, binding = 2) readonly buffer PermutationPrefactors {
// size == PERMUTATIONS * expressionSize
    float permutationPrefactors[];
};

layout (std430, set = 2, binding = 1) buffer SquaredDeviations {
// size == BATCH_SIZE * PERMUTATIONS
    float squaredDeviations[];
};

/*

| opkind          | immediate  | functionID  |
|-----------------|------------|-------------|
| OPKIND_VARIABLE | dimension  | unused      |
| OPKIND_CONSTANT | pool index | unused      |
| OPKIND_FUNCTION | arity      | function ID |


*/
struct TreeNode {
    uint opkind;
    uint immediate;
    uint functionID;
};

layout (std140, set = 2, binding = 0) readonly buffer Tree {
// must contain exactly `expressionSize` elements
    TreeNode tree[];
};

layout (std430, push_constant) uniform PushConstants {
    uint datapoints;
    uint preimageDimensions;
    uint expressionSize;
};

layout (local_size_x = WORKGROUP_SIZE_X, local_size_y = WORKGROUP_SIZE_Y, local_size_z = 1) in;

float _prefactor(uint permutationIdx, uint nodeIdx);
float _sample(uint batchIdx, uint dimension);
float _function(uint functionID, uint sp, float stack[STACK_SIZE]);
float _eval(uint batchIdx, uint permutationIdx, uint expressionSize);


void main() {
    uint batchIdx = gl_GlobalInvocationID.x;
    uint permutationIdx = gl_GlobalInvocationID.y;
    bool skip = batchIdx >= BATCH_SIZE || permutationIdx >= PERMUTATIONS;

    if (!skip) {
        float result = _eval(batchIdx, permutationIdx, expressionSize);
        float actual = image[batch[batchIdx]];
        float deviation = result - actual;
        float squaredDeviation = deviation * deviation;
        squaredDeviations[permutationIdx * BATCH_SIZE + batchIdx] = squaredDeviation;
    }
}

float _prefactor(uint permutationIdx, uint nodeIdx) {
    return permutationPrefactors[permutationIdx * MAX_TREE_SIZE + nodeIdx];
}

float _sample(uint batchIdx, uint dimension) {
    return preimage[batch[batchIdx] * preimageDimensions + dimension];
}

float _eval(uint batchIdx, uint permutationIdx, uint treeSize) {
    float stack[STACK_SIZE];
    uint sp = 0;
    for (int tp = int(treeSize); tp >= 0; tp -= 1) {
        TreeNode node = tree[tp];
        float result = 0.0;
        uint arity = node.immediate;
        switch (node.opkind) {
            case OPKIND_VARIABLE:
            uint dimension = node.immediate;
            result = _sample(batchIdx, dimension);
            break;
            case OPKIND_CONSTANT:
            uint constantIdx = node.immediate;
            result = constants[constantIdx];
            break;
            case OPKIND_FUNCTION:
            result = _function(node.functionID, sp, stack);
            sp -= arity;
            break;
        }
        stack[sp] = _prefactor(permutationIdx, tp) * result;
        sp += 1;
    }
    return stack[sp];
}