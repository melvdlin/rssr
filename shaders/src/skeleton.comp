#version 460

/*  required #defines:

    BATCH_SIZE: batch size; the x dimension of the work group
    PERMUTATIONS: number of permutations; the y dimension of the work group
    STACK_SIZE: size of private stack; should not be smaller than expression tree


    OPKINDs: uint literals
    - OPKIND_VARIABLE
    - OPKIND_CONSTANT
    - OPKIND_BUILTIN_OPERATOR
    - OPKIND_BUILTIN_FUNCTION
    - OPKIND_CUSTOM_FUNCTION

    OPIDs: uint literals
    - OPID_ADD
    - OPID_SUBTRACT
    - OPID_MULTIPLY
    - OPID_DIVIDE
    - OPID_NEGATE


    required #includes:

        builtin-function-evaluation:
        must define a function definition of prototype
        `float _builtinFunction(uint functionID, uint sp, uint stack[STACK_SIZE]);`
        that translates the `functionID` into a builtin function call
        using the operands on the stack

        custom-function-evaluation:
        must define a function definition of prototype
        `_customFunction(uint functionID, uint sp, uint stack[STACK_SIZE])`
        that translates the `functionID` into a custom function call
        using the operands on the stack

        custom-function-definitions:
        must contain definitions of the functions used in custom-function-evaluation.
*/

layout (std140, set = 0, binding = 0) readonly buffer Preimage {
    float preimage[];
};

layout (std140, set = 0, binding = 1) readonly buffer Image {
    float image[];
};

layout (std140, set = 0, binding = 2) readonly buffer ConstantPool {
    float constants[];
};

// a set of indices into the preimage; batch size == number of summands in MSD per permutation
layout (std140, set = 0, binding = 3) readonly buffer Batch {
    // size == BATCH_SIZE
    uint batch[];
};

// prefactors to multiply a tree node by; one per node
layout (std140, set = 0, binding = 4) readonly buffer PermutationPrefactors {
    // size == PERMUTATIONS * expressionSize
    uint permutationPrefactors[];
};

layout (std140, set = 0, binding = 5) buffer SquaredDeviations {
    // size == BATCH_SIZE * PERMUTATIONS
    float squaredDeviations[];
};

/*

| opkind                  | immediate        | functionID          |
| ----------------------- | ---------------- | ------------------- |
| OPKIND_VARIABLE         | dimension        | unused              |
| OPKIND_CONSTANT         | pool index       | unused              |
| OPKIND_BUILTIN_OPERATOR | arity            | builtin operator ID |
| OPKIND_BUILTIN_FUNCTION | arity            | builtin function ID |
| OPKIND_CUSTOM_FUNCTION  | arity            | custom function ID  |


builtin operators:

| opID     | arity |
| -------- | ----- |
| ADD      |     2 |
| SUBTRACT |     2 |
| MULTIPLY |     2 |
| DIVIDE   |     2 |
| NEGATE   |     1 |

*/
struct TreeNode {
    uint opkind;
    uint immediate;
    uint functionID;
};

layout (std140, set = 0, binding = 6) readonly buffer Tree {
    // must contain exactly `expressionSize` elements
    TreeNode tree[];
};

layout (push_constant) uniform PushConstants {
    uint datapoints;
    uint preimageDimensions;
    uint expressionSize;
};

layout (local_size_x = BATCH_SIZE, local_size_y = PERMUTATIONS, local_size_z = 1) in;

uint _prefactor(uint permutationIdx, uint nodeIdx);
float _sample(uint batchIdx, uint dimension);
float _eval(uint batchIdx, uint permutationIdx, uint expressionSize);
float _builtinOperator(uint opID, uint sp, uint stack[STACK_SIZE]);
float _builtinFunction(uint functionID, uint sp, uint stack[STACK_SIZE]);
float _customFunction(uint functionID, uint sp, uint stack[STACK_SIZE]);


void main() {
    uint batchIdx = gl_GlobalInvocationID.x;
    uint permutationIdx = gl_GlobalInvocationID.y;
    bool skip = batchIdx >= BATCH_SIZE || permutationIdx >= PERMUTATIONS;

    if (!skip) {
        float result = _eval(batchIdx, permutationIdx, expressionSize);
        float actual = image[batch[batchIdx]];
        float deviation = result - actual;
        float squaredDeviation = deviation * deviation;
        squaredDeviations[permutationIdx * BATCH_SIZE + batchIdx] = squaredDeviation;
    }
}

uint _prefactor(uint permutationIdx, uint nodeIdx) {
    return permutationPrefactors[permutationIdx * expressionSize + nodeIdx];
}

float _sample(uint batchIdx, uint dimension) {
    return preimage[batch[batchIdx] * preimageDimensions + dimension];
}

#include "custom-function-definitions"

float _eval(uint batchIdx, uint permutationIdx, uint treeSize) {
    float stack[STACK_SIZE];
    uint sp = 0;
    for (int tp = treeSize; tp >= 0; tp -= 1) {
        TreeNode node = tree[tp];
        float result = 0.0;
        uint arity = node.immediate;
        switch (node.opkind) {
            case OPKIND_VARIABLE:
                uint dimension = node.immediate;
                result = _sample(batchIdx, dimension);
                break;
            case OPKIND_CONSTANT:
                uint constantIdx = node.immediate;
                result = constants[constantIdx];
                break;
            case OPKIND_BUILTIN_OPERATOR:
                result = _builtinOperator(node.functionID, sp, stack);
                sp -= arity;
                break;
            case OPKIND_BUILTIN_FUNCTION:
                result = _builtinFunction(node.functionID, sp, stack);
                sp -= arity;
                break;
            case OPKIND_CUSTOM_FUNCTION:
                result = _customFunction(node.functionID, sp, stack);
                sp -= arity;
                break;
        }
        stack[sp] = _prefactor(permutationIdx, tp) * result;
    }
    return stack[sp];
}

float _builtinOperator(uint opID, uint stack[STACK_SIZE]) {
    switch (opID) {
        case OPID_ADD: return stack[sp - 1] + stack[sp - 2];
        case OPID_SUBTRACT: return stack[sp - 1] - stack[sp - 2];
        case OPID_MULTIPLY: return stack[sp - 1] * stack[sp - 2];
        case OPID_NEGATE: return -1.0 * stack[sp - 1];
        default: return 0.0;
    }
}

#include "builtin-function-evaluation"
#include "custom-function-evaluation"
