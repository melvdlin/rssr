#version 460

/*  required #defines:

    BATCH_SIZE: batch size; the x dimension of the work group
    PERMUTATIONS: number of permutations; the y dimension of the work group
    STACK_SIZE: size of private stack; should not be smaller than expression tree


    OPKINDs: uint literals
    - OPKIND_VARIABLE
    - OPKIND_CONSTANT
    - OPKIND_FUNCTION

    required #includes:

        function-evaluation:
        must define a function definition
        of prototype `float _function(uint id, uint sp, float stack[STACK_SIZE])`
        that translates the `functionID` into a function (
        of prototype `float _functionXYZ(float p1, float p2, ..., float pn)`
        ) call using the operands on the stack

        function-definitions:
        must contain definitions of the functions used in function-evaluation.
*/

layout (std140, set = 0, binding = 0) readonly buffer Preimage {
    float preimage[];
};

layout (std140, set = 0, binding = 1) readonly buffer Image {
    float image[];
};

layout (std140, set = 0, binding = 2) readonly buffer ConstantPool {
    float constants[];
};

// a set of indices into the preimage; batch size == number of summands in MSD per permutation
layout (std140, set = 0, binding = 3) readonly buffer Batch {
// size == BATCH_SIZE
    uint batch[];
};

// prefactors to multiply a tree node by; one per node
layout (std140, set = 0, binding = 4) readonly buffer PermutationPrefactors {
// size == PERMUTATIONS * expressionSize
    uint permutationPrefactors[];
};

layout (std140, set = 0, binding = 5) buffer SquaredDeviations {
// size == BATCH_SIZE * PERMUTATIONS
    float squaredDeviations[];
};

/*

| opkind          | immediate  | functionID  |
| ----------------| ---------- | ------------|
| OPKIND_VARIABLE | dimension  | unused      |
| OPKIND_CONSTANT | pool index | unused      |
| OPKIND_FUNCTION | arity      | function ID |


*/
struct TreeNode {
    uint opkind;
    uint immediate;
    uint functionID;
};

layout (std140, set = 0, binding = 6) readonly buffer Tree {
// must contain exactly `expressionSize` elements
    TreeNode tree[];
};

layout (push_constant) uniform PushConstants {
    uint datapoints;
    uint preimageDimensions;
    uint expressionSize;
};

layout (local_size_x = BATCH_SIZE, local_size_y = PERMUTATIONS, local_size_z = 1) in;

uint _prefactor(uint permutationIdx, uint nodeIdx);
float _sample(uint batchIdx, uint dimension);
float _eval(uint batchIdx, uint permutationIdx, uint expressionSize);
float _function(uint functionID, uint sp, uint stack[STACK_SIZE]);


void main() {
    uint batchIdx = gl_GlobalInvocationID.x;
    uint permutationIdx = gl_GlobalInvocationID.y;
    bool skip = batchIdx >= BATCH_SIZE || permutationIdx >= PERMUTATIONS;

    if (!skip) {
        float result = _eval(batchIdx, permutationIdx, expressionSize);
        float actual = image[batch[batchIdx]];
        float deviation = result - actual;
        float squaredDeviation = deviation * deviation;
        squaredDeviations[permutationIdx * BATCH_SIZE + batchIdx] = squaredDeviation;
    }
}

uint _prefactor(uint permutationIdx, uint nodeIdx) {
    return permutationPrefactors[permutationIdx * expressionSize + nodeIdx];
}

float _sample(uint batchIdx, uint dimension) {
    return preimage[batch[batchIdx] * preimageDimensions + dimension];
}

#include "function-definitions"

float _eval(uint batchIdx, uint permutationIdx, uint treeSize) {
    float stack[STACK_SIZE];
    uint sp = 0;
    for (int tp = int(treeSize); tp >= 0; tp -= 1) {
        TreeNode node = tree[tp];
        float result = 0.0;
        uint arity = node.immediate;
        switch (node.opkind) {
            case OPKIND_VARIABLE:
            uint dimension = node.immediate;
            result = _sample(batchIdx, dimension);
            break;
            case OPKIND_CONSTANT:
            uint constantIdx = node.immediate;
            result = constants[constantIdx];
            break;
            case OPKIND_FUNCTION:
            result = _function(node.functionID, sp, stack);
            sp -= arity;
            break;
        }
        stack[sp] = _prefactor(permutationIdx, tp) * result;
        sp += 1;
    }
    return stack[sp];
}
//
//float _builtinOperator(uint opID, uint sp, float stack[STACK_SIZE]) {
//    switch (opID) {
//        case OPID_ADD: return stack[sp - 1] + stack[sp - 2];
//        case OPID_SUBTRACT: return stack[sp - 1] - stack[sp - 2];
//        case OPID_MULTIPLY: return stack[sp - 1] * stack[sp - 2];
//        case OPID_NEGATE: return -1.0 * stack[sp - 1];
//        default : return 0.0;
//    }
//}

#include "function-evaluation"
