#version 460

#define BATCH_SIZE 64
#define PERMUTATIONS 32
#define STACK_SIZE 96
#define OPKIND_VARIABLE 0
#define OPKIND_CONSTANT 1
#define OPKIND_FUNCTION 2

/*  required #defines:

    BATCH_SIZE: batch size; the x dimension of the work group
    PERMUTATIONS: number of permutations; the y dimension of the work group
    STACK_SIZE: size of private stack; should not be smaller than expression tree

    OPKINDs: uint literals
    - OPKIND_VARIABLE
    - OPKIND_CONSTANT
    - OPKIND_FUNCTION

    a definition of the `_eval` function is also required
*/

layout (std430, set = 0, binding = 0) readonly buffer Preimage {
    float preimage[];
};

layout (std430, set = 0, binding = 1) readonly buffer Image {
    float image[];
};

layout (std430, set = 1, binding = 0) readonly buffer ConstantPool {
    float constants[];
};

// a set of indices into the preimage; batch size == number of summands in MSD per permutation
layout (std430, set = 1, binding = 1) readonly buffer Batch {
// size == BATCH_SIZE
    uint batch[];
};

// prefactors to multiply a tree node by; one per node
layout (std430, set = 1, binding = 2) readonly buffer PermutationPrefactors {
// size == PERMUTATIONS * expressionSize
    float permutationPrefactors[];
};

layout (std430, set = 2, binding = 1) buffer SquaredDeviations {
// size == BATCH_SIZE * PERMUTATIONS
    float squaredDeviations[];
};

/*

| opkind          | immediate  | functionID  |
|-----------------|------------|-------------|
| OPKIND_VARIABLE | dimension  | unused      |
| OPKIND_CONSTANT | pool index | unused      |
| OPKIND_FUNCTION | arity      | function ID |


*/
struct TreeNode {
    uint opkind;
    uint immediate;
    uint functionID;
};

layout (std140, set = 2, binding = 0) readonly buffer Tree {
// must contain exactly `expressionSize` elements
    TreeNode tree[];
};

layout (std430, push_constant) uniform PushConstants {
    uint datapoints;
    uint preimageDimensions;
    uint expressionSize;
};

layout (local_size_x = BATCH_SIZE, local_size_y = PERMUTATIONS, local_size_z = 1) in;

float _prefactor(uint permutationIdx, uint nodeIdx);
float _sample(uint batchIdx, uint dimension);
float _eval(uint batchIdx, uint permutationIdx, uint expressionSize);
float _function(uint functionID, uint sp, float stack[STACK_SIZE]);


void main() {
    uint batchIdx = gl_GlobalInvocationID.x;
    uint permutationIdx = gl_GlobalInvocationID.y;
    bool skip = batchIdx >= BATCH_SIZE || permutationIdx >= PERMUTATIONS;

    if (!skip) {
        float result = _eval(batchIdx, permutationIdx, expressionSize);
        float actual = image[batch[batchIdx]];
        float deviation = result - actual;
        float squaredDeviation = deviation * deviation;
        squaredDeviations[permutationIdx * BATCH_SIZE + batchIdx] = squaredDeviation;
    }
}

float _prefactor(uint permutationIdx, uint nodeIdx) {
    return permutationPrefactors[permutationIdx * expressionSize + nodeIdx];
}

float _sample(uint batchIdx, uint dimension) {
    return preimage[batch[batchIdx] * preimageDimensions + dimension];
}

float _eval(uint batchIdx, uint permutationIdx, uint treeSize) {
    float stack[STACK_SIZE];
    uint sp = 0;
    for (int tp = int(treeSize); tp >= 0; tp -= 1) {
        TreeNode node = tree[tp];
        float result = 0.0;
        uint arity = node.immediate;
        switch (node.opkind) {
            case OPKIND_VARIABLE:
            uint dimension = node.immediate;
            result = _sample(batchIdx, dimension);
            break;
            case OPKIND_CONSTANT:
            uint constantIdx = node.immediate;
            result = constants[constantIdx];
            break;
            case OPKIND_FUNCTION:
            result = _function(node.functionID, sp, stack);
            sp -= arity;
            break;
        }
        stack[sp] = _prefactor(permutationIdx, tp) * result;
        sp += 1;
    }
    return stack[sp];
}
float _function0(float lhs, float rhs) {
    return lhs + rhs;
}


float _function1(float lhs, float rhs) {
    return lhs - rhs;
}


float _function2(float lhs, float rhs) {
    return lhs * rhs;
}


float _function3(float lhs, float rhs) {
    return lhs / rhs;
}


float _function4(float rhs) {
    return rhs * -1;
}


float _function5(float x) {
    return sin(x);
}


float _function6(float x, float lo, float hi) {
    if (x < lo) {
        return lo;
    }
    if (x > hi) {
        return hi;
    }
    return x;
}

float _function(uint id, uint sp, float stack[96u]) {
    switch (id) {
        case 0u:
        return _function0(stack[sp - 1u], stack[sp - 2u]);
        case 1u:
        return _function1(stack[sp - 1u], stack[sp - 2u]);
        case 2u:
        return _function2(stack[sp - 1u], stack[sp - 2u]);
        case 3u:
        return _function3(stack[sp - 1u], stack[sp - 2u]);
        case 4u:
        return _function4(stack[sp - 1u]);
        case 5u:
        return _function5(stack[sp - 1u]);
        case 6u:
        return _function6(stack[sp - 1u], stack[sp - 2u], stack[sp - 3u]);
    }
    return 0.;
}